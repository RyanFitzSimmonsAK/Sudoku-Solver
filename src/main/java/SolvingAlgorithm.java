import java.util.ArrayList;

public class SolvingAlgorithm {

    /**
     * A backtracking algorithm using recursion to procedurally fill in the board.
     * @param board The current board state.
     * @param boxes The boxes generated by the current board state.
     * @return Returning a 0 indicates that the board state is invalid, and a backtrack should occur.  Returning a 1 indicates that the board is solved.
     */
    public static Integer solve(Board board, ArrayList<ArrayList<Cell>> boxes) {

        /* Traverses the board starting from the top left, and ending at the bottom right.  */
        for (ArrayList<Cell> row : board.board) {
            for (Cell cell : row) {

                /* If the cell value is 0, then it's not a provided hint, and should be changed.  */
                if (cell.value == 0) {

                    /* Checks a potential value, checks if the board state is legal, and backtracks if it's not.  */
                    for (int option : cell.available) {
                        cell.value = option;

                        if (ValidityChecker.legalBoardState(board, boxes)) {
                            /* If the board is complete, we can return 1, and exit our recursions. */
                            if (ValidityChecker.isComplete(board, boxes)) {
                                return 1;
                            }

                            /* If the board is not complete, then we recurse, moving onto the next cell.  */
                            else {
                                Integer nextStep = solve(board, boxes);

                                if (nextStep == 0) {
                                    /* This checks if more than one backtrack is necessary.  When a backtrack occurs, if this cell is already 9 (meaning it
                                     * has no more values it can check), then another backtrack occurs.  */
                                    if (cell.value == 9) {
                                        cell.value = 0;
                                        return 0;
                                    }
                                    /* If a second backtrack is not necessary, then it just continues checking values for this cell. */
                                    continue;
                                }
                            }
                            /* If the board is complete, we can return 1, and exit our recursions. */
                            if (ValidityChecker.isComplete(board, boxes)) {
                                return 1;
                            }
                        }
                        else {
                            /* This checks if more than one backtrack is necessary.  When a backtrack occurs, if this cell is already 9 (meaning it
                             * has no more values it can check), then another backtrack occurs.  */
                            if (cell.value == 9) {
                                cell.value = 0;
                                return 0;
                            }
                        }
                    }
                }
            }
        }
        return 1;
    }
}
